<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<meta name="Generator" content="EditPlus®">
		<meta name="Author" content="">
		<meta name="Keywords" content="">
		<meta name="Description" content="">
		<title>Document</title>

		<style>
			pre {white-space:pre-line;}
            ul {padding-left: 20px;}
            ol {padding-left: 20px;}
		</style>
	</head>
	<body>
		<div style="padding: 20px;">
			<h3>먼저 본질을 이해하고 시작하자.</h3>
			<p>
				새로운 기술을 다룰 때 중요한 것은 그 본질을 제대로 파악하는 것이다. 
				표면적인 노하우만을 습득하는 것만으로는 다양한 환경에서 응용하기 어렵고, 기억할 것들이 너무 많아져 금방 잃어 버리게 된다. 
				또한 이런 단순한 지식들은 새로운 기술이 등장해 버리면 금방 사라지고 그 가치를 잃어버리는 경우가 많다.
			</p>
			<hr/>
            <ul>
                <li>목록</li>
                <ol>
                    <li><a href="./index.html">Home</a></li>
                    <li><a href="./security.html">Security</a></li>
					<li><a href="./docker.html">Docker</a></li>
					<li><a href="./kubernetes.html">Kubernetes</a></li>
					<li><a href="./linux.html">Linux</a></li>
                    <li><a href="./language.html">Language</a></li>
					<li><a href="./webserver.html">Web Server</a></li>
					<li><a href="./was.html">Was</a></li>
					<li><a href="./git.html">Git</a></li>
					<li><a href="./network.html">Network</a></li>
                </ol>
            </ul>
			<hr/>

			<h4>Docker</h4>
			<ol>
				<li>용어</li>
				<ul>
					<li>컨테이너 : 앱이 구동되는 환경까지 감싸서 실행할 수 있도록 하는 격리 기술</li>
					<li>컨테이너 런타임 : 컨테이너를 다루는 도구</li>
					<li>오케스트레이션 : 여러 서버에 컨테이너를 분산 배치, 상태 관리 및 컨테이너의 구동 환경까지 관리</li>
					<li>
						쿠버네티스 : 컨테이너 런타임을 통해 컨테이너를 오케스트레이션 하는 도구</br>
						종류 : Kubernetes, Docker Swarm, Apache Mesos
					</li>
				</ul>
				<li>구조</li>
				<img src="./images/container.jpg"/>
				</br>
				<sub>
					애플리케이션 배포 환경의 변화(Virtualized Development)</br>
					출처 : https://kubernetes.io/ko
				</sub>
				
				<li>Base Image</li>
				<ul>
					<li>Linux</li>
					<ul>
						<li>Ubuntu</li>
						<li>Debian</li>
						<li>CentOS</li>
						<li>Alpine</li>
					</ul>
					<li>Language</li>
					<ul>
						<li>Python</li>
						<li>Node.js</li>
						<li>Java</li>
						<li>Ruby</li>
						<li>Go</li>
						<li>PHP</li>
					</ul>
					<li>Web Server</li>
					<ul>
						<li>Nginx</li>
						<li>Apache</li>
						<li>WebtoB</li>
					</ul>
					<li>WAS</li>
					<ul>
						<li>Apache Tomcat</li>
						<li>Jetty</li>
						<li>Red Hat JBoss EAP</li>
						<li>Jeus</li>
						<li>IBM WebSphere Application Server</li>
						<li>WebLogic Server</li>
						<li>WildFly</li>
					</ul>
					<li>DB</li>
					<ul>
						<li>MySQL</li>
						<li>PostgreSQL</li>
						<li>MongoDB</li>
						<li>Redis</li>
						<li>CouchDB</li>
						<li></li>
					</ul>
					<li>FrameWork</li>
					<ul>
						<li>Django</li>
						<li>Flask</li>
						<li>Spring Boot</li>
						<li>Ruby on Rails</li>
					</ul>

				</ul>
				
				<li>명령어</li>
				<ul>
					<li>$ docker [대상] [액션]</li>
					<ul>
						<li>[대상] : container(생략가능), image, volume, network ...</li>
						<li>[액션] : ls, inspect, start, run, build, rename ...</li>
					</ul>
				</ul>
				<ul>
					<li>Docker</li>
					<ul>
						<li>$ docker login : 도커 허브에 로그인</li>
						<li>$ docker images : 이미지 목록</li>
						<li>$ docker build -t [image-name]:[tag] [Dockerfile 위치] : 이미지 빌드(생성)</li>
						<ki>$ docker rmi [image-name]:[tag] : 이미지 삭제 (tag은 tag값이 있을 경우)</ki>
						<li>$ docker create --name [container-name] [image-name]:[tag] : 컨테이너 생성(latest경우 tag 생략 가능)</li>
						<ul>
							<li>-it</li>
							<ul>
								<li>-i (--interactive) : 표준 입력(STDIN)을 활성화함. 컨테이너와 attach 되어있지 않더라도 표준 입력을 유지함.
								</li>
								<li>-t (--tty) : 컨테이너에 pseudo-terminal을 할당</li>
							</ul>
							<li>--name : 컨테이너의 이름을 지정 (default:random)</li>
							<li>local repository에 이미지가 없으면 기본으로 Docker Hub에서 이미지를 pull한다.</li>
						</ul>
						<li>$ docker rename [current-name] [chang-name] : 컨테이너 이름 바꾸기</li>
						<ul>
							<li>-t : 이미지 태그를 지정하겠다 </li>
						</ul>
						<li>$ docker ps -a --no-trunc : 실행중인 컨테이너 목록 확인</li>
						<ul>
							<li>-a : 전체 컨테이너 목록 확인</li>
							<li>--no-trunc : 컨테이너 ID 전체 확인</li>
							<li>출력 결과 항목</li>
							<ul>
								<li>CONTAINER ID : 컨테이너에 할당되는 고유한 컨테이너 ID(전체 ID에서 12자리만 출력)</li>
								<li>IMAGE : 컨테이너를 생성할 때 사용된 이미지</li>
								<li>COMMAND : 컨테이너가 시작될 때 실행될 명령어</br>docker run 이나 docker create 명령어의 맨 끝에 새로운 명령어를 입력해서 컨테이너를 생성할 때 대체 가능</li>
								<li>CREATED : 컨테이너 생성 후 경과 시간</li>
								<li>STATUS : 컨테이너의 상태(실행 중(Up), 종료(Exited), 일시 중지(Pause))</li>
								<li>PORT : 컨테이너가 개방한 포트와 호스트에 연결된 포트
								</li>
								<li>NAMES : 컨테이너 이름
								</li>
							</ul>
						</ul>
						<li>$ docker start -ai [container-name] : 컨테이너 실행</li>
						<ul>
							<li>-a(--attach) : 해당 컨테이너 내부로 접근</li>
						</ul>
						<li>$ docker stop [container-id] : 해당 컨테이너 실행 중지</li>
						
						<li>$ docker run -dit --name [container-name] [image-name] [temp command] : 쉘 스크립트 버전 | 서버 </li>
						<ul>
							<li>-d : 직접 컨테이너 안으로 접근하지 않고, 컨테이너의 COMMAND를 백그라운드로 실행</li>
							<li>-i : 인터랙티브 모드로 컨테이너를 실행 즉, 컨테이너와 상호작용</li>
							<li>-t : 가상의 tty(터미널)를 컨테이너에 연결하여 쉘을 실행하거나 다른 명령을 실행할 때 터미널과 유사한 환경을 제공 </li>
						</ul>
						<li>$ docker run -dp [호스트:포트]:[컨테이너 포트] [image-name] : 호스트 버전 | 호스트의 포트와 컨테이너 포트를 매핑하여 실행</li>
						<li>$ docker run -d -p [호스트:포트]:[컨테이너 포트] --name [container-name] [image-name]:[tag] : 호스트-포트포워딩 컨테이너 실행</li>
						<ul>
							<li>-d : 직접 컨테이너 안으로 접근하지 않고, 컨테이너의 COMMAND를 백그라운드로 실행</li>
							<li>
								-p : 컨테이너의 포트를 호스트의 포트에 매핑</br>
								컨테이너 내부의 서비스나 애플리케이션이 호스트의 네트워크에서 접근 가능하도록 사용
							</li>
							<ul>
								<li>[호스트:포트]: 호스트에서 열릴 포트입니다. 이것은 외부에서 컨테이너로 접속하기 위한 포트입니다.</li>
								<li>[컨테이너 포트]: 컨테이너 내에서 노출되는 포트입니다. 컨테이너 내에서 실행 중인 서비스가 사용하는 포트입니다.</li>
								<li>EX : 호스트의 8080 포트를 컨테이너의 80 포트에 매핑하려면 -> docker run -p 8080:80 [이미지 이름] 으로 사용</li>
							</ul>
						</ul>
						<li>$ docker -f rm [container-id] : 해당 컨테이너 삭제</li>
						<ul>
							<li>-f : (force) 옵션 사용시 중지와 삭제를 한번에 실행</li>
						</ul>
						<li>$ docker stats : 동작 중인 컨테이너의 상태와 사용 중인 리소스의 양을 확인</li>
						<li>$ docker top [container-name] : 동작 중인 컨테이너에서 실행되고 있는 프로세스 확인</li>
						
						
						<li>$ docker start -i [container-id] : 상태가 Exited된 해당 컨테이너 실행</li>
						<li>$ docker exec -it [container-id] 또는 [container-name] [temp command] : 이미 실행 중인 컨테이너 내에서 새로운 명령을 실행하기 위해 사용(세션 연결 없음)</li>
						<li>$ docker attach [container-id] 또는 [container-name] : 이미 실행 중인 컨테이너의 터미널에 현재 터미널 세션을 연결</li>

						<li>container 종료</li>
						<ul>
							<li>ctrl + P + Q : 종료 없이 나가기</li>
							<li>exit or ctrl + D : 종료</li>
						</ul>

						<li>TODO *조달청 수정 필요</li>
						<pre>
							# docker 이미지 추가
							docker load < magicmrsv2_v1.0.0.2.tar

							# 도커 이미지 확인
							docker images

							# 도커 컨테이너 실행
							docker run -it -p 80:80 -p 30711:30711 54de480f4865 /bin/bash

							# 도커 컨테이너 종료
							docker stop [컨테이너id]

							# 도커 접속
							docker exec -it 87eaa9a18cc7 /bin/sh

							# 도커 이미지 제거
							docker rmi [이미지id]

							# 도커 파일 옮기기
							docker cp [보낼파일경로] [컨테이너id]:[받을파일경로]/Users/dream/Downloads/테이블 생성 스크립트/oracle/fido2server_oracle_all.sql/Users/dream/Downloads/테이블 생성 스크립트/oracle/fido2server_oracle_all.sql

							# 도커 이미지 저장
							docker save -o [이미지이름].tar magicmrsv2_pps:v1.0.0
						</pre>
					</ul>

					<li>Docker Hub</li>
					<ul>
						<li>push</li>
						<ol>
							<li>docker-hub 로그인</li>
							<li>이미지를 만든다 ([docker-id]/[push-image-name]:[tag])</li>
							<li>이미지 푸쉬</li>
						</ol>
						<li>pull</li>
						<ol>
							<li>docker-hub 로그인</li>
							<li>docker-hub의 repository에서 내려받기</li>
						</ol>
						<li>save = layer형식 이미지를 tar파일로 추출 (image -> tar)</li>
						<li>load = 내려받은 layer 형식 이미지tar 파일을 이미지로 만들기 (tar -> image)</li>
						<li>export = 동작중인 컨테이너를 tar파일로 추출</li>
						<li>import = 내려받은 컨테이너 tar파일을 가져오기</li>
						<li>명령어</li>
						<ul>
							<li>$ docker login -u [ID] : Docker Hub Login</li>
							<li>$ docker logout : Docker Hub Logout</li>
							<li>$ docker build -t [docker-hub-name]/[push-image-name]:[tag] [Dockerfile 위치]: 이미지 빌드</li>
							<li>$ docker tag [image-name]:[tag] [docker-hub-id or private registry ip:port]/[push-image-name] : 도커이미지를 이름을 변경하거나 태그 붙이기</li>
							<li>$ docker push [docker-hub-id]/[push-image-name]:[tag] : docker-hub에 이미지 올리기</li>
							<li>$ docker pull [docker-hub-id]/[image-name]:[tag] : docker-hub에서 이미지 받아오기</li>
							<li>$ docker commit -m [image-description] -a [user-mail] [container-name or container-iD] [new-image-name]:[tag] : 현재 컨테이너를 이미지로 만들기</li>
							<li>$ docker save -o [저장할 디렉토리]/[저장할 tar 이름] [image-name]:[tag] : layer형식 이미지를 tar파일로 추출 (image -> tar)</li>
							<li>$ docker load -i [file-name] : 내려받은 layer 형식 이미지tar 파일을 이미지로 만들기 (tar -> image)</li>
							<li>$ docker export [container-name or container-id] > [file-name] : 해당 컨테이너를 tar파일로 추출</li>
							<li>$ docker import [file-name] [image-name]:[tag] : 해당 컨테이너 tar파일을 이미지로 만들기 </li>
							<li>$ docker import --change 'CMD [명령어]' [file-name] [image-name]:[tag] : 해당 컨테이너 tar파일을 이미지로 만들기 (컨테이너가 기동된 후 실행할 커맨드가 필요할때 )</li>
						</ul>
					</ul>
				</ul>
				<li>Dockerfile</li>
				<ul>
					<li>설명</li>
					<ul>
						<li>Dockerfile의 설정 읽어 yarn app의 종속성을 설치 </li>
						<li>순수 text file</li>
						<li>docker build시 Dockerfile을 사용하여 새 이미지를 빌드</li>
					</ul>
					<li>예제설정
						<pre>
							FROM node:18-alpine
							WORKDIR /app
							COPY . .
							RUN yarn install --production
							CMD ["node", "src/index.js"]
							EXPOSE 3000	
						</pre>			
					</li>
					<ul>
						<li>FROM node:18-alpine : 빌더에게 이미지에서 시작하고 싶다고 지시</li>
						<li>WORKDIR /app : work directory</li>
						<li>CMD ["node", "src/index.js"] : 이미지에서 컨테이너를 시작할 때 실행할 기본 명령어를 지정 </li>
					</ul>
				</ul>
				<li>애플리케이션 업데이트</li>
				<ul>
					<li>기존 컨테이너 제거</li>
					<li>기존 컨테이너 ID 가져오기 </li>
					<li>기존 컨테이너 중지</li>
					<li>기존 컨테이너 삭제</li>
				</ul>
			</ol>

			<pre>
				<h3>ETC</h3>
				1. Naming Convention(명명 규칙)
				- 패키지명 : com.ssjae

				- 요소별 명명 :

				config : 프로젝트와 관련된 설정 클래스들의 보관 패키지
				controller : 스프링 MVC의 Controller들의 보관 패키지
				service : 스프링 Service 인터페이스와 구현 클래스 패키지
				domain : VO, DTO 클래스들의 패키지
				persistence : MyBatis Mapper 인터페이스 패키지(데이터계층 패키지)
				exception : 웹 관련 예외처리 패키지
				aop : 스프링의 AOP 관련 패키지
				security : 스프링 Security 관련 패키지
				util : 각종 유틸리티 클래스 관련 패키지(개발하기를 위해 도움이 되는 클래스들)
				2. Service
				Controller에서 각 메소드의 비즈니스 로직은 Service로 따로 빼서 작성을 한다.
				Service 인터페이스를 만들고 각 인터페이스에 맞는 class를 만들어준다.

				그리고 인터페이스에 맞는 class위에다가 Service로 만들었다는 것을 Spring에게 알려주기 위해
				@Service를 써줘야 하며 root-context.xml에 Service 클래스가 어디있는지 알려줘야 한다.


				3. domain
				domain패키지는 관련된 DTO들의 클래스들을 모아두는 곳이다.

				공통
				대소문자 구분
				예약어 X
				숫자로 시작 X
				특수문자는 _ 혹은 $ 만 허용
				파스칼 표기법과 카멜 표기법을 사용
				반의어는 반드시 대응하는 개념으로 사용

				1️⃣ 프로젝트
				대소문자 구분없이 시작 가능
				대문자 사용을 권장

				2️⃣ 패키지
				대소문자 모두 허용하지만, 클래스명과 쉽게 구분하기 위해 소문자로 하는 것을 원칙
				표준 패턴을 따른다. EX) [com].[Company].[Project].[toppackage].[lowerpackage]
				가급적 한 단어 사용 권장
				좋은 예: com.nexon.Maplstory.member.object
				나쁜 예: com.nexon.MaplestoryMemberObject

				3️⃣ 클래스
				파스칼 표기법 사용
				명사로 시작
				EX) HelloWorld, TestWorld
				4️⃣ 인터페이스
				파스칼 표기법 사용
				형용사를 사용
				EX) Runnable, Remote
				5️⃣ 메서드
				카멜 표기법 사용
				동사로 시작
				메서드명의 여러 접두사
				속성에 접근: get/set
				데이터 생성: create
				데이터 조회: find
				데이터 변경: modify
				데이터 삭제: delete
				데이터 입력: input
				데이터 초기화: init
				데이터 불러오기: load
				데이터 유무 확인: has
				B를 기준으로 A를 하겠다: By
				EX) public void getUserByName()
				6️⃣ 변수와 상수
				변수

				카멜 표기법
				상수

				전부 대문자로 표기
				스네이크 케이스 사용
			</pre>

			<pre>
				docker container 와 image 관계
				ChatGPT
				도커(Docker)에서 컨테이너(Container)와 이미지(Image)는 밀접한 관계를 가지고 있습니다. 이 둘은 독립적으로 존재하며, 동시에 서로에게 영향을 줍니다.
				
				이미지(Image):
				
				이미지는 컨테이너를 실행하기 위한 템플릿입니다.
				컨테이너가 시작될 때 파일 시스템, 애플리케이션 코드, 라이브러리, 환경 변수 등을 정의합니다.
				이미지는 Dockerfile을 사용하여 정의됩니다. Dockerfile에는 이미지를 만들기 위한 명령어들이 포함됩니다.
				이미지는 읽기 전용이며, 한 번 생성되면 변경할 수 없습니다.
				컨테이너(Container):
				
				컨테이너는 이미지를 기반으로 실행된 실행 가능한 인스턴스입니다.
				컨테이너는 이미지를 사용하여 시작됩니다. 즉, 이미지를 가져와서 파일 시스템과 프로세스를 실행합니다.
				컨테이너는 읽기/쓰기 가능한 레이어를 추가하여 이미지에서 파생됩니다. 이 레이어는 컨테이너가 실행되는 동안 변경되고 저장됩니다.
				컨테이너는 프로세스가 실행되는 격리된 환경을 제공하며, 호스트와 분리되어 있습니다.
				따라서 이미지는 컨테이너를 생성하기 위한 템플릿으로 생각할 수 있습니다. 컨테이너는 이미지를 가져와서 실행되는 인스턴스로, 컨테이너가 종료되면 변경 사항이 유실됩니다. 이미지는 여러 개의 컨테이너를 생성할 수 있고,
				한 이미지에서 파생된 여러 컨테이너는 각각 독립적인 실행 환경을 갖습니다.
				
				
				
				
				User
				docker 하나의 이미지로 여러개의 컨테이너
				ChatGPT
				도커(Docker)에서는 하나의 이미지로 여러 개의 컨테이너를 생성할 수 있습니다. 이미지는 동일한 구성 및 환경을 가지고 있으므로, 이를 기반으로 여러 개의 컨테이너를 생성할 수 있습니다. 이는 여러 컨테이너 간에
				코드나 데이터를 공유해야 할 때 유용합니다.
				
				예를 들어, 웹 서버를 실행하는 이미지를 사용하여 여러 개의 웹 서버 컨테이너를 실행할 수 있습니다. 각 컨테이너는 다른 포트에서 동작하거나 다른 네트워크 환경에서 실행될 수 있습니다. 또한, 데이터베이스를 실행하는
				이미지를 사용하여 여러 개의 데이터베이스 인스턴스를 실행할 수도 있습니다.
				
				다음은 이미지를 기반으로 여러 개의 컨테이너를 실행하는 예제입니다:
				
				bash
				Copy code
				# 동일한 이미지로 웹 서버 컨테이너 3개를 실행하는 예제
				docker run -d --name web_server1 -p 8080:80 my_web_server_image
				docker run -d --name web_server2 -p 8081:80 my_web_server_image
				docker run -d --name web_server3 -p 8082:80 my_web_server_image
				위의 예제에서는 my_web_server_image라는 이미지를 기반으로 8080, 8081, 8082 포트에서 각각 세 개의 웹 서버 컨테이너를 실행합니다.
				
				이렇게 하나의 이미지로 여러 개의 컨테이너를 실행할 수 있으며, 각 컨테이너는 서로 다른 인스턴스이므로 독립적으로 실행됩니다.
				
				User
				docker was,db,app 하나의 컨테이너
				ChatGPT
				하나의 컨테이너에 여러 개의 서비스를 넣는 것은 일반적으로 권장되지 않습니다. 이유는 다음과 같습니다:
				
				단일 책임 원칙(Single Responsibility Principle): 각 컨테이너는 하나의 서비스 또는 프로세스에 대해 책임을 집중해야 합니다. 서로 다른 서비스를 하나의 컨테이너에 넣으면 관리가 어려워지고,
				서비스 간의 의존성이 높아질 수 있습니다.
				
				스케일링: 서비스를 분리하면 각 서비스를 독립적으로 스케일링할 수 있습니다. 예를 들어, 웹 애플리케이션과 데이터베이스가 함께 있는 컨테이너를 사용하면 웹 애플리케이션과 데이터베이스를 모두 스케일링해야 합니다.
				
				보안: 여러 서비스가 하나의 컨테이너에 있는 경우, 보안에 취약할 수 있습니다. 각 서비스를 분리하여 컨테이너화하면 각 서비스에 대한 보안을 개별적으로 관리할 수 있습니다.
				
				대신, 여러 개의 컨테이너를 사용하여 각각의 서비스를 분리하고, 필요에 따라 Docker Compose 또는 Kubernetes와 같은 오케스트레이션 도구를 사용하여 서비스 간의 통신을 관리할 수 있습니다.
				
				예를 들어, 웹 어플리케이션, 데이터베이스, 백그라운드 작업 등을 각각의 컨테이너로 분리하여 실행할 수 있습니다. 그러면 각 서비스를 독립적으로 스케일링하고 관리할 수 있습니다.
				
				yaml
				Copy code
				vetsion: '3'
				services:
				app:
				image: myapp_image
				ports:
				- "8080:80"
				db:
				image: mysql:latest
				environment:
				MYSQL_ROOT_PASSWORD: example
				MYSQL_DATABASE: mydatabase
				worker:
				image: myworker_image
				# 추가 설정...
				위와 같이 Docker Compose를 사용하여 각 서비스를 정의하고, 필요한 설정을 추가할 수 있습니다. 이렇게 하면 각 서비스가 독립적으로 실행되고 관리됩니다.
				
				User
				docker 여러개의 컨테이너 연결
				ChatGPT
				여러 개의 도커 컨테이너를 연결하는 것은 일반적으로 네트워크를 통해 이루어집니다. 이를 통해 컨테이너 간에 통신할 수 있습니다. 여러 컨테이너를 하나의 애플리케이션으로 조합하거나, 각각의 서비스를 분리하여 실행하고
				통신할 수 있습니다.
				
				도커에서 컨테이너를 연결하는 방법에는 여러 가지가 있습니다. 주로 사용되는 방법 중 일부는 다음과 같습니다:
				
				Docker 네트워크(Docker Network):
				도커는 기본적으로 브리지 네트워크를 제공하여 컨테이너를 연결합니다. 이 네트워크를 사용하여 동일한 네트워크에 속한 컨테이너는 서로 통신할 수 있습니다.
				
				도커 컴포즈(Docker Compose):
				도커 컴포즈를 사용하면 여러 개의 컨테이너를 정의하고 연결하는 데 편리한 방법을 제공합니다. docker-compose.yml 파일을 사용하여 컨테이너 간의 관계를 정의하고, 하나의 명령으로 여러 컨테이너를 관리할
				수 있습니다.
				
				도커 스웜(Docker Swarm) 또는 쿠버네티스(Kubernetes):
				도커 스웜이나 쿠버네티스와 같은 오케스트레이션 도구를 사용하면 여러 호스트에 분산되어 있는 컨테이너를 연결하고 관리할 수 있습니다. 이러한 도구는 서비스 디스커버리, 로드 밸런싱, 스케일링 등을 제공하여 복잡한
				애플리케이션 아키텍처를 관리할 수 있습니다.
				
				컨테이너 간의 통신은 주로 IP 주소나 호스트명을 사용하여 이루어집니다. 따라서 각 컨테이너는 다른 컨테이너의 IP 주소나 호스트명을 알고 있어야 합니다. 위에 언급된 방법들을 사용하여 컨테이너를 연결하고 필요한
				설정을 수행하여 통신할 수 있습니다.
				
				User
				docker image.tar파일
				ChatGPT
				Docker 이미지를 .tar 파일로 내보내거나 가져오는 것은 일반적인 작업입니다. 이미지를 .tar 파일로 내보내려면 docker save 명령을 사용하고, .tar 파일에서 이미지를 가져오려면 docker
				load 명령을 사용합니다.
				
				이미지 내보내기 (.tar 파일로 저장):
				bash
				Copy code
				docker save -o image.tar image_name:tag
				여기서 image_name:tag는 내보내고자 하는 이미지의 이름과 태그입니다. -o 옵션은 파일로 출력하도록 지시합니다.
				
				이미지 가져오기 (.tar 파일에서 불러오기):
				bash
				Copy code
				docker load -i image.tar
				여기서 -i 옵션은 입력 파일로부터 이미지를 불러오도록 지시합니다.
				
				이러한 명령들은 이미지의 모든 레이어와 메타데이터를 포함하는 .tar 파일을 생성하거나 불러올 수 있습니다. 이것은 이미지를 저장하고 나중에 다른 시스템에 이동하거나 공유할 때 유용합니다.
				
				User
				docker 하나의 이미지에 여러 서비스
				ChatGPT
				하나의 Docker 이미지에 여러 서비스를 포함하는 것은 일반적으로 권장되지 않습니다. Docker의 설계 철학은 각 컨테이너가 하나의 프로세스 또는 서비스에만 집중하도록 하는 것이며, 이를 통해 컨테이너를 보다
				격리되고 관리하기 쉽도록 합니다.
				
				하지만 경우에 따라서는 하나의 이미지 안에 여러 서비스를 포함하는 것이 필요할 수 있습니다. 이를 위해 다음과 같은 방법들이 있습니다:
				
				Supervisor 또는 systemd를 사용한 멀티 서비스 컨테이너:
				
				하나의 컨테이너 안에서 여러 프로세스를 실행하는 방법으로, Supervisor 또는 systemd와 같은 프로세스 관리 도구를 사용합니다. 이러한 도구를 사용하여 각 서비스를 관리하고 실행할 수 있습니다.
				하나의 서비스가 종료되면 Supervisor나 systemd가 다른 서비스를 다시 시작할 수 있습니다.
				이 방법은 일반적으로 복잡하며, 컨테이너의 단일 책임 원칙에 위배될 수 있습니다.
				서비스 메시(Multi-Service Mesh) 아키텍처:
				
				여러 개의 컨테이너를 생성하여 각각의 컨테이너가 하나의 서비스를 담당하도록 설계합니다.
				이러한 컨테이너들은 네트워크를 통해 통신하고, 필요에 따라 Docker Compose나 Kubernetes와 같은 도구를 사용하여 관리할 수 있습니다.
				컨테이너 안에서 여러 프로세스 실행:
				
				하나의 컨테이너 안에서 여러 프로세스를 실행하는 것은 일반적으로 권장되지 않지만, 특정한 경우에는 적용할 수 있습니다.
				이 경우에는 주로 단일 책임 원칙을 준수하기 위한 방어적인 조치를 취해야 합니다.
				이러한 방법들 중에서도 각 서비스를 별도의 컨테이너로 분리하여 관리하는 것이 일반적으로 가장 권장되는 방법입니다. 이를 통해 각 서비스를 독립적으로 스케일링하고 업데이트할 수 있으며, 시스템 전체적으로 유연성과
				안정성을 높일 수 있습니다.
				
				User
				docker 여러개의 이미지 통합
				ChatGPT
				여러 개의 Docker 이미지를 통합하여 하나의 이미지로 만들기 위해서는 여러 이미지를 하나의 Dockerfile에서 기반 이미지로 사용하고, 각 이미지의 설정 및 파일들을 복사하는 등의 작업을 수행해야 합니다.
				이렇게 하나의 Dockerfile에 여러 이미지를 통합하여 새로운 이미지를 만들면, 이를 통해 여러 서비스 또는 컴포넌트를 함께 실행할 수 있습니다.
				
				예를 들어, 다음은 여러 개의 이미지를 통합하여 하나의 이미지로 만드는 간단한 예제입니다:
				
				Dockerfile
				Copy code
				# 첫 번째 이미지를 기반 이미지로 사용합니다.
				FROM image1:tag1 AS image1
				
				# 두 번째 이미지를 기반 이미지로 사용합니다.
				FROM image2:tag2 AS image2
				
				# 기반 이미지를 정의합니다.
				FROM ubuntu:20.04
				
				# 필요한 패키지 설치 또는 설정을 수행합니다.
				RUN apt-get update && apt-get install -y some-package
				
				# 첫 번째 이미지에서 파일을 복사합니다.
				COPY --from=image1 /path/to/file /destination/path1
				
				# 두 번째 이미지에서 파일을 복사합니다.
				COPY --from=image2 /path/to/file /destination/path2
				위의 Dockerfile에서는 먼저 두 개의 이미지인 image1과 image2를 각각 AS 키워드를 사용하여 정의합니다. 그런 다음, FROM 키워드를 사용하여 기반 이미지를 정의하고, 각 이미지에서 필요한 파일을
				COPY 명령을 통해 복사합니다.
				
				이렇게 하나의 Dockerfile에 여러 이미지를 통합하여 새로운 이미지를 만들면, 이 이미지를 통해 여러 서비스를 함께 실행할 수 있습니다. 단일 이미지로의 통합을 통해 배포 및 관리가 간편해지며, 여러 컴포넌트
				간의 종속성 관리가 간소화됩니다.
				
				User
				docker layer란?
				ChatGPT
				도커(Docker) 이미지는 여러 개의 읽기 전용 레이어로 구성됩니다. 각 레이어는 파일 시스템의 변경 사항을 나타냅니다. 이러한 레이어들은 서로 겹쳐져 있고, 이것이 도커의 이미지의 가볍고 효율적인 관리를 가능하게
				합니다. 각 레이어는 파일 또는 디렉토리의 변경사항을 포함하고 있으며, 변경된 부분만 새로운 레이어로 추가됩니다. 이러한 레이어들의 개념을 "도커 레이어(Docker Layer)"라고 합니다.
				
				도커 레이어의 특징은 다음과 같습니다:
				
				읽기 전용(Immutable): 각 레이어는 읽기 전용이며 변경되지 않습니다. 이미지를 수정하면 새로운 레이어가 생성되고, 변경된 부분만 새로운 레이어에 반영됩니다.
				
				재사용(Reusability): 레이어들은 다른 이미지에서 재사용될 수 있습니다. 예를 들어, 여러 이미지가 같은 기본 운영 체제나 공통 패키지를 사용하는 경우, 해당 레이어는 한 번만 저장되고 여러 이미지에서
				공유됩니다.
				
				캐싱(Caching): 도커는 이미지 빌드 시 이전 레이어들을 캐싱하여 재사용합니다. 이는 이미지 빌드 속도를 높이고, 동일한 변경 사항이 여러 이미지에서 반복되는 경우 효율성을 높입니다.
				
				계층적 구조(Hierarchical Structure): 레이어들은 상위 레이어와 하위 레이어의 계층적 구조를 가지며, 이를 통해 이미지의 변경 이력을 관리할 수 있습니다. 이는 이미지의 버전 관리와 롤백을 용이하게
				합니다.
				
				레이어를 통해 변경 사항을 관리하는 것은 이미지의 크기를 최소화하고, 이미지를 효율적으로 공유하고 배포하는 데 도움이 됩니다.
				
				User
				docker image id
				ChatGPT
				도커 이미지의 고유 식별자는 이미지 ID입니다. 이 ID는 각 이미지마다 고유하며, 이미지의 변경 이력을 추적하고 관리하는 데 사용됩니다. 이미지 ID는 일반적으로 12자의 16진수로 표현되지만, 일부 도구에서는
				짧은 접두사만 사용하여 식별할 수도 있습니다.
				
				도커 이미지 ID를 확인하려면 다음 명령을 사용합니다:
				
				bash
				Copy code
				docker images
				위 명령을 실행하면 시스템에 현재 저장된 모든 도커 이미지 목록이 표시됩니다. 각 이미지에는 REPOSITORY, TAG, IMAGE ID, CREATED, SIZE 등의 정보가 포함되어 있습니다. 여기서 IMAGE
				ID 열에 해당하는 값이 도커 이미지의 고유 식별자입니다.
				
				또는 특정 이미지의 ID를 확인하려면 이미지의 이름 또는 태그를 지정하여 다음과 같이 docker inspect 명령을 사용할 수 있습니다:
				
				bash
				Copy code
				docker inspect <image_name_or_id/>
				위 명령을 실행하면 해당 이미지의 세부 정보가 JSON 형식으로 출력되며, 여기서 Id 필드에 해당하는 값이 이미지의 고유 식별자입니다.
			
				도커 이미지 ID는 이미지를 고유하게 식별하는 데 사용되므로, 이미지를 참조하거나 관리할 때 유용하게 활용됩니다.
			
				User
				docker manifest.json
				ChatGPT
				도커(Docker) 이미지의 manifest.json 파일은 멀티 아키텍처 이미지를 정의하는 메타데이터 파일입니다. 멀티 아키텍처 이미지는 동일한 이미지의 여러 버전을 호환되는 여러 아키텍처에 대해 빌드하고
				저장하는 방식을 의미합니다.
			
				manifest.json 파일은 다음과 같은 정보를 포함합니다:
			
				이미지의 아키텍처 및 운영 체제 정보: 각 이미지의 아키텍처와 운영 체제에 대한 정보를 포함합니다. 이 정보는 Docker Hub 및 다른 이미지 레지스트리에서 호환 가능한 이미지를 선택하는 데 사용됩니다.
			
				이미지의 레이어 정보: 각 이미지의 레이어 ID 및 해당 레이어를 가져오는 데 사용되는 디지털 지문(Digest)을 포함합니다.
			
				다중 플랫폼 지원: 멀티 아키텍처 이미지의 경우, 여러 아키텍처에 대한 정보가 포함됩니다. 이를 통해 도커 런타임이 호스트 시스템의 아키텍처에 맞는 이미지를 자동으로 선택할 수 있습니다.
			
				manifest.json 파일은 Docker 이미지 레지스트리에 업로드되며, 도커 클라이언트가 이미지를 푸시하거나 풀할 때 자동으로 생성됩니다.
			
				일반적으로 manifest.json 파일을 직접 편집할 필요는 없으며, 대부분의 경우 도커 클라이언트 및 레지스트리가 이를 자동으로 관리합니다. 그러나 이미지의 아키텍처 정보를 확인하거나 특정 이미지의
				레이어를 분석할 때 유용할 수 있습니다.
			
				User
				docker was container, app container
				ChatGPT
				Docker를 사용하여 WAS(Web Application Server) 컨테이너와 애플리케이션 컨테이너를 구성하는 방법은 다양합니다. 일반적으로 WAS와 애플리케이션을 분리하여 각각을 별도의 컨테이너로
				실행하는 것이 권장되는 방법입니다.
			
				WAS 컨테이너(WAS Container):
			
				WAS 컨테이너는 웹 어플리케이션 서버를 실행하는 데 사용됩니다. 대표적으로 Apache Tomcat, Jetty, WildFly(JBoss), IBM WebSphere 등이 있습니다.
				WAS 컨테이너는 웹 애플리케이션의 배포와 관리를 담당합니다. 일반적으로 웹 애플리케이션의 WAR 파일을 배포하여 실행합니다.
				WAS 컨테이너는 보통 백엔드 데이터베이스와 통신하고, 클라이언트 요청을 처리하여 동적 콘텐츠를 생성합니다.
				애플리케이션 컨테이너(App Container):
			
				애플리케이션 컨테이너는 WAS 컨테이너에서 실행되는 웹 애플리케이션을 담당합니다.
				애플리케이션 컨테이너는 WAS 컨테이너와 통신하여 웹 애플리케이션을 실행하고, 클라이언트 요청에 따라 WAS로부터 받은 데이터를 처리하여 응답을 생성합니다.
				각 애플리케이션 컨테이너는 독립적으로 실행되며, 여러 개의 애플리케이션 컨테이너를 스케일링하거나 업데이트할 수 있습니다.
				이러한 방법으로 WAS와 애플리케이션을 분리하면 애플리케이션을 더 쉽게 관리하고 확장할 수 있습니다. 또한, 각 컨테이너가 독립적으로 실행되기 때문에 장애가 발생했을 때 한 컨테이너가 다른 컨테이너에 영향을
				미치지 않습니다. 이를 통해 애플리케이션의 가용성과 신뢰성을 높일 수 있습니다.
			
				User
				docker was container, app container 연결
				ChatGPT
				Docker를 사용하여 WAS(Web Application Server) 컨테이너와 애플리케이션 컨테이너를 연결하는 방법은 여러 가지가 있습니다. 주로 네트워크를 통해 컨테이너 간의 통신을 설정하거나
				Docker Compose를 사용하여 여러 컨테이너를 한 번에 관리하는 방법을 사용합니다.
			
				네트워크를 통한 통신 설정:
			
				WAS 컨테이너와 애플리케이션 컨테이너 간의 통신은 네트워크를 통해 이루어집니다. 따라서 두 컨테이너를 같은 네트워크에 속하도록 설정해야 합니다.
				Docker의 기본 네트워크인 브리지 네트워크를 사용할 수 있습니다. 컨테이너를 실행할 때 --network 옵션을 사용하여 동일한 네트워크에 속하도록 지정할 수 있습니다.
				Docker Compose 사용:
			
				Docker Compose를 사용하면 여러 컨테이너를 한 번에 관리할 수 있습니다. docker-compose.yml 파일에 컨테이너 및 네트워크 구성을 정의하여 관리합니다.
				예를 들어, WAS 컨테이너와 애플리케이션 컨테이너를 같은 docker-compose.yml 파일에 정의하고, 각 컨테이너가 같은 네트워크에 속하도록 설정할 수 있습니다.
				환경 변수 또는 설정 파일을 통한 연결 설정:
			
				WAS 컨테이너와 애플리케이션 컨테이너 간의 연결 정보를 환경 변수나 설정 파일을 통해 전달할 수 있습니다. 예를 들어, WAS 컨테이너의 호스트 및 포트 정보를 애플리케이션 컨테이너의 환경 변수로 설정하여
				애플리케이션에서 사용할 수 있습니다.
				이러한 방법들을 사용하여 WAS 컨테이너와 애플리케이션 컨테이너를 연결하면, 두 컨테이너 간의 통신이 가능해지고, 웹 애플리케이션이 정상적으로 작동할 수 있습니다. 이때 중요한 점은 네트워크 설정 및 컨테이너
				간의 통신을 올바르게 설정하여 서로가 정상적으로 연결되도록 하는 것입니다.
			
				User
				docker 통합 이미지 만드는 방법
				ChatGPT
				도커(Docker)에서 통합 이미지를 만드는 방법은 이미지 레이어를 통합하는 것입니다. 여러 이미지를 하나의 이미지로 통합하려면 다음과 같은 절차를 따를 수 있습니다:
			
				기존 이미지들 준비:
			
				통합할 이미지들을 미리 준비합니다. 각 이미지는 독립적으로 빌드되어야 합니다.
				하나의 이미지로 통합하기 위한 Dockerfile 작성:
			
				통합할 이미지들을 사용하여 하나의 Dockerfile을 작성합니다.
				각 이미지를 FROM 명령을 통해 기반 이미지로 지정하고, 필요한 경우 다른 명령을 사용하여 각 이미지의 설정 및 파일을 통합합니다.
				이미지 빌드:
			
				작성한 Dockerfile을 사용하여 통합 이미지를 빌드합니다.
				다음과 같이 명령을 실행합니다:
				Copy code
				docker build -t integrated_image .
				통합 이미지 테스트:
			
				생성된 통합 이미지를 로컬에서 테스트하여 기능이 정상적으로 동작하는지 확인합니다.
				통합 이미지 공유 또는 배포:
			
				통합된 이미지를 Docker Hub 또는 다른 이미지 레지스트리에 푸시하여 공유하거나, 클러스터 환경에 배포합니다.
				다음은 간단한 예제 Dockerfile입니다. 이 예제는 두 개의 이미지를 통합하는 방법을 보여줍니다:
			
				Dockerfile
				Copy code
				# 첫 번째 이미지를 기반 이미지로 사용합니다.
				FROM image1:tag1 AS image1
			
				# 두 번째 이미지를 기반 이미지로 사용합니다.
				FROM image2:tag2 AS image2
			
				# 기반 이미지를 정의합니다.
				FROM ubuntu:20.04
			
				# 필요한 패키지 설치 또는 설정을 수행합니다.
				RUN apt-get update && apt-get install -y some-package
			
				# 첫 번째 이미지에서 파일을 복사합니다.
				COPY --from=image1 /path/to/file /destination/path1
			
				# 두 번째 이미지에서 파일을 복사합니다.
				COPY --from=image2 /path/to/file /destination/path2
				위의 Dockerfile은 두 개의 이미지(image1과 image2)를 통합하여 하나의 이미지로 만드는 예제입니다. 이렇게 하나의 이미지로 통합하여 더 큰 애플리케이션을 구성할 수 있습니다.
			</pre>
		</div>
	</body>
</html>
